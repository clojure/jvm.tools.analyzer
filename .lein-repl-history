(use 'clojure.pprint)
(pprint '{:bases #{clojure.lang.CljCompiler.Ast.StaticFieldOrPropertyExpr`1[[System.Reflection.FieldInfo, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] clojure.lang.CljCompiler.Ast.AssignableExpr clojure.lang.CljCompiler.Ast.MaybePrimitiveExpr clojure.lang.CljCompiler.Ast.Expr}, :flags #{:sealed :before-field-init :class :auto-layout :ansi-class}, :members #{#clojure.reflect.Method{:name EvalAssign, :return-type System.Object, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.Expr], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Property{:name CanEmitPrimitive, :type System.Boolean, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Method{:name get_ClrType, :return-type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public :special-name}} #clojure.reflect.Property{:name FieldType, :type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Property{:name ClrType, :type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Method{:name get_CanEmitPrimitive, :return-type System.Boolean, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public :special-name}} #clojure.reflect.Method{:name EmitAssign, :return-type System.Void, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.RHC clojure.lang.CljCompiler.Ast.ObjExpr clojure.lang.CljCompiler.Ast.CljILGen clojure.lang.CljCompiler.Ast.Expr], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Method{:name get_FieldType, :return-type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :family :special-name}} #clojure.reflect.Method{:name EmitUnboxed, :return-type System.Void, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.RHC clojure.lang.CljCompiler.Ast.ObjExpr clojure.lang.CljCompiler.Ast.CljILGen], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Constructor{:name .ctor, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [System.String clojure.lang.IPersistentMap clojure.lang.Symbol System.Type System.String System.Reflection.FieldInfo], :flags #{:hide-by-sig :reuse-slot :public :special-name :rt-special-name}} #clojure.reflect.Method{:name Eval, :return-type System.Object, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public}}}}
)
(pprint '{:bases #{clojure.lang.CljCompiler.Ast.StaticFieldOrPropertyExpr`1[[System.Reflection.FieldInfo, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]] clojure.lang.CljCompiler.Ast.AssignableExpr clojure.lang.CljCompiler.Ast.MaybePrimitiveExpr clojure.lang.CljCompiler.Ast.Expr}, :flags #{:sealed :before-field-init :class :auto-layout :ansi-class}, :members #{#clojure.reflect.Method{:name EvalAssign, :return-type System.Object, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.Expr], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Property{:name CanEmitPrimitive, :type System.Boolean, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Method{:name get_ClrType, :return-type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public :special-name}} #clojure.reflect.Property{:name FieldType, :type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Property{:name ClrType, :type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :flags #{}} #clojure.reflect.Method{:name get_CanEmitPrimitive, :return-type System.Boolean, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public :special-name}} #clojure.reflect.Method{:name EmitAssign, :return-type System.Void, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.RHC clojure.lang.CljCompiler.Ast.ObjExpr clojure.lang.CljCompiler.Ast.CljILGen clojure.lang.CljCompiler.Ast.Expr], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Method{:name get_FieldType, :return-type System.Type, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :family :special-name}} #clojure.reflect.Method{:name EmitUnboxed, :return-type System.Void, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [clojure.lang.CljCompiler.Ast.RHC clojure.lang.CljCompiler.Ast.ObjExpr clojure.lang.CljCompiler.Ast.CljILGen], :flags #{:hide-by-sig :virtual :reuse-slot :public}} #clojure.reflect.Constructor{:name .ctor, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [System.String clojure.lang.IPersistentMap clojure.lang.Symbol System.Type System.String System.Reflection.FieldInfo], :flags #{:hide-by-sig :reuse-slot :public :special-name :rt-special-name}} #clojure.reflect.Method{:name Eval, :return-type System.Object, :declaring-class clojure.lang.CljCompiler.Ast.StaticFieldExpr, :parameter-types [], :flags #{:hide-by-sig :virtual :reuse-slot :public}}}})
